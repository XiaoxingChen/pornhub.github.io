---
title: Numerical Accuracy of Inverse Rodrigues Implementation
date: 2020-03-12 
mathjax: true
hidden: true
tags:
---
<head>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
    <style>
        .bib ol {
            counter-reset: item
        }

        .bib li {
            display: block;
            counter-increment: item;
        }

        .bib li:before {
            content: " ["counter(item)"] ";
        }
    </style>

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
    <h2>Background</h2>
    <p>The famous Rodrigues Formula describes the transform between rotation matrix and rotation vector. 
        It is also the exponential map from \(\mathfrak{so}(3)\) to \(SO(3)\).
    </p>
    \[
        R = cos\theta I + (1 - cos\theta) \omega \omega^\top + sin\theta \omega^\wedge
        \tag{1-1}
    \]
    <p>
        The transform rotation matrix back to rotation vector can be obtained by expanding matrix \(R\) in formulate (1-1).
        Defining \(v_\theta = 1 - cos\theta\),\(c_\theta = cos\theta\), and \(s_\theta = sin\theta\)
    </p>
    \[
        R = 
        \left[
        \begin{matrix}

        \end{matrix}
        \right]
        \tag{1-2}
    \]
    <p>Therefore</p>
    \[
        \theta = \text{cos}^{-1} 
        \left(
            \frac{\text{trace}(R)}{2}
        \right) 
        \tag{1-3}
    \]

    \[
        \omega = \frac{1}{2 \text{sin}\theta}
        \left[\begin{matrix}
        r_{32} - r_{23} \\ r_{13} - r_{31} \\ r_{21} - r_{12}
        \end{matrix}\right]
        \tag{1-4}
    \]

    <p>Here are several problems need to be considered in real engineering problem.
        For example, when \(\text{sin}\theta \rightarrow 0\), \(\omega\) goes to singularity.
        And the matrix \(R\) may not be strictly unit orthogonal. 
        Therefore, we take the code of <b>opencv</b> as example.
        <a href="https://github.com/opencv/opencv/blob/master/modules/calib3d/src/calibration.cpp#L362">
            opencv/modules/calib3d/src/calibration.cpp
        </a>
    </p>
    
    <h3>1.  Singular Value Decomposition</h3>
    <p>Use SVD to make matrix \(R\) strictly unit orthogonal.</p>
    <pre><code class="language-cpp">
        Matx33d U, Vt;

        SVD::compute(R, W, U, Vt);
        R = U*Vt;
    <code></pre>
</body>