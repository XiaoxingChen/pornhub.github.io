---
title: Particle Filter with GPU Implementation
date: 2020-10-4
hidden: false
mathjax: true
tags:
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
        <style>
            .bib ol { counter-reset: item }
            .bib li { display: block ; counter-increment: item; }
            .bib li:before { content: " ["counter(item)"] "; }

            code.md{
                background-color:#eee;
                color:deeppink;
                border-radius: 3px;
                border:1px solid #888;
                padding: 2px 2px;
            }
            pre.md{
                background-color:#eee;
                border-radius: 3px;
                border: 1px solid #888 ;
            }
            blockquote.md{
                padding: 0 1em;
                border-left: .25em solid #888;
            }
        </style>

</head>
<body>
    <p>A toy example helps understand OpenCL and particle filter <a href="https://github.com/XiaoxingChen/gpu_particle_filter">[source code]</a>.</p>
    <h2>Notations</h2>
    <ul>
        <li>state vector: \(\mathrm{x} \in \mathfrak{se}(2)\)</li>
        <li>motion noise: \(\mathrm{w}\)</li>
        <li>motion measurement: \(\mathrm{v}\)</li>
        <li>observation: \(\mathrm{y}\)</li>
        <li>motion model: \(\mathrm{x}_k = f(\mathrm{x}_{k-1}, \mathrm{v}_k, \mathrm{w}_k)\), \(k = 1, \dots, K\)</li>
        <li>observation model: \(\mathrm{y}_k = g(\mathrm{x}_k, \mathrm{n}_k)\), \(k = 0, \dots, K\)</li>
        <li>Number of particles: \(N\)</li>
        <li>Weight of particles: \(\omega\)</li>

    </ul>

    <h2>Estimation</h2>
    <p><b>1. Prediction</b></p>
    <p>Unlike steps in the <a title="State estimation for robotics">textbook</a><sup><a href="" title="http://asrl.utias.utoronto.ca/~tdb/bib/barfoot_ser17.pdf">[1]</a></sup>, I do prediction before sampling particles.</p>

    \[
        \hat{\mathrm{x}}_{k} = f(\mathrm{x}_{k-1}, \mathrm{v}_k, \mathrm{w}_{k})
        \tag{2-1}
    \]

    <p><b>2. Particle sampling </b></p>
    \[
        \left[
        \begin{matrix}
            \check{\mathrm{x}}_{k,m} \\
            \mathrm{w}_{k,m}
        \end{matrix}
        \right]
        \leftarrow

        p(\hat{\mathrm{x}}_{k}) p(\mathrm{w}_{k-1})
        \tag{2-2}
    \]

    <p><b>3. Likelihood calculation</b></p>
    <p>Here I use the likelihood between the simulated LiDAR measurement to actual LiDAR sensor data as the particle weight.</p>
    \[
        \omega_{k,m} \propto p(y_k | \check{\mathrm{x}}_{k,m}) = p(y_k | \check{\mathrm{y}}_{k,m})
        \tag{2-3}
    \]
    <p>LiDAR measurement model: </p>
    \[
        p(y_k|\check{\mathrm{y}}_{k,m}) =
        \begin{cases}
        \text{PDF}(y_k - \check{\mathrm{y}}_{k,m}) && \text{ if } \ y_k, \check{\mathrm{y}}_{k,m} \le L_{max}), \\
        1 - \text{CDF}(y_k - \check{\mathrm{y}}_{k,m}) && \text{ if } \ y_k > L_{max} \text{ or } \check{\mathrm{y}}_{k,m} > L_{max}, \\
        \epsilon && \text{else}
        \end{cases}
        \tag{2-4}
    \]

    <p>
        \(L_{max}\) means the maximum measure distance of the LiDAR sensor.
        \(\text{PDF}\) is the probabilistic distribution function of the sensor model,
        a gaussian model is used in this project.
        \(\text{CDF}\) is the cumulative distribution function of the sensor model.
        \(epsilon\) is a constant small value in code implementation which minimizes the impact of
        overranged LiDAR beam.
    </p>

    <p><b>4. Resampling</b></p>
    <p>I use the method in this paper<sup><a href="https://cse.sc.edu/~terejanu/files/tutorialMC.pdf">[2]</a></sup> to do resampling.
    <a href="https://leetcode.com/problems/random-pick-with-weight/">Leetcode 528</a> is also helpful for understanding.</p>

    <h2>Parallelization</h2>
    <p>
        In this project, I use line segments to represent objects in map without any acceleration structure.
        For a single line LiDAR with resolution \(H\), working in a map with \(S\) segments, a particle filter with \(N\) particles has to
        calculate line intersection for with complexity \(O(H \times S \times N)\). While those calculations are totally independent,
        it is available to do parallelization. The determination of line segment intersection is presented here<sup><a href="https://xiaoxingchen.github.io/2018/10/13/planar_line_segment_intersection/">[4]</a></sup>.
    </p>
    <p>
        After eliminating the LiDAR beams that never intersect with objects, the rest beams' measure distances were calculated.
        <a href="https://en.wikipedia.org/wiki/Reduction_Operator">Parallel reduction</a> was used to find the "close hit" among all intersections of a single LiDAR beam.
    </p>

    <p>
        Besides, the likelihood between simulation and actual measurement are also calculated in GPU.
        To avoid float point overflow, the calculation was done in logarithmic space.
        For there is no built-in cumulative gaussian function in OpenCL, it is <a href="https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function">approximated by error function</a>:
    </p>
    \[
        \text{CDF}(x) = \frac{1}{2}
        \left[
        1 + \text(erf)(\frac{x - \mu}{\sigma \sqrt 2})
        \right]
    \]

    <h2>Experiments</h2>
    <h3>Ice World</h3>
    <figure>
        <img src="https://user-images.githubusercontent.com/16934019/80937927-a1e1c880-8e09-11ea-99cb-6fa34e88f895.gif" style="width:70%">
        <figcaption>
            Fig.1 - LiDAR resolution: 32, LiDAR measure distance: 50 meters, particle number: 512.
        </figcaption>
    </figure>

    <h3>Featureless Corridor</h3>
    <figure>
        <img src="https://user-images.githubusercontent.com/16934019/80937931-aa3a0380-8e09-11ea-9937-49a308e7e95d.gif" style="width:70%">
        <figcaption>
            Fig.2 - LiDAR measure distance: 20 meters. As shown in the image, particle filter can easily lost in feature less scenario.
            The covariance in longitudinal direction increase drastically while in lateral direction it is till stable.
            The localization converge immediately when LiDAR beam detects corner.
        </figcaption>
    </figure>


    <h3>Circular Corridor</h3>
    <figure>
        <img src="https://user-images.githubusercontent.com/16934019/80937934-ac03c700-8e09-11ea-95ee-2300c933b5f3.gif" style="width:70%">
        <figcaption>
            Fig.3 - The localization is stable the LiDAR beam matches well to the wall. However the estimated position deviated from the actual position.
            In this situation, one dimension of the localization is unobservable(need confirm).
        </figcaption>
    </figure>
    <h2>References</h2>
    <p>
        <ol class="bib">
            <li>
                Barfoot, Timothy D.
            <cite>
                <a href="http://asrl.utias.utoronto.ca/~tdb/bib/barfoot_ser17.pdf">"State estimation for robotics."</a>
            </cite>
                Cambridge University Press, 2017.
            </li>
            <li>
            Terejanu, Gabriel A.
            <cite>
                <a href="https://cse.sc.edu/~terejanu/files/tutorialMC.pdf">"Tutorial on Monte Carlo Techniques." </a>
            </cite>
                Department of Computer Science and Engineering. University at Buffalo (2009).
            </li>
            <li>
                Atsushi, Sakai.
                <a href="https://github.com/AtsushiSakai/PythonRobotics/blob/master/Localization/particle_filter/particle_filter.py">"PythonRobotics."</a>
            </li>
            <li>
                Xiaoxing, Chen.
                <a href="https://xiaoxingchen.github.io/2018/10/13/planar_line_segment_intersection/">"Determine Intersection of Two Planar Line Segments"</a>
            </li>
        </ol>
    </p>
</body>
</html>