---
title: Dual Number and Auto Derivative of Special Orthogonal Group
date: 2022-03-20
mathjax: true
hidden: false
tags:
---

<head>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
    <style>
        .bib ol {
            counter-reset: item
        }

        .bib li {
            display: block;
            counter-increment: item;
        }

        .bib li:before {
            content: " ["counter(item)"] ";
        }
    </style>

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <h1 id="background">Background</h1>
    <p>
        Finding the closed-form Jacobian matrix of a residual function is one of the most time consuming works
        in solving a nonlinear optimization problem.
        A work around is to use numerical Jacobian. i.e. manually give a small increment in every
        variable and find out the increment in residual. However the selection of the increment
        depends on the data magnitude. An inappropriate increment can lead to fluctuation before convergence.
    </p>
    <p>
        In google <a href="http://ceres-solver.org/">ceres-solver</a>, an auto derivative method is introduced to
        liberate developers from complicated Jacobian debugging. This blog introduces the principle behind the auto derivative
        and explains a <i>Perspective-N-Point</i> problem demo based on auto derivative and nonlinear optimization.
    </p>

    <h1 id="dual_number_albegra">Dual Number Algebra</h1>
    <p>
        The basic idea of auto derivative is to extend the input of a single variable function.
        Consider function \(y = f(x)\), the input \(x\) is no longer a variable, but an out put
        of another function with first order slop \( b\varepsilon \). Where \(\varepsilon\) is the basis of the
        increment, real number \(b\) measures the magnitude of the increment. Therefore, variable \(x\)
        is expressed as \(x = a + b \varepsilon\).
    </p>
    <p>Define \(\varepsilon ^2 = 0\) to drop infinitesimals with order higher than one.</p>

    <h2 id="addition">Addition</h2>
    \[
        (a + b \varepsilon) + (c + d \varepsilon) = (a + c) + (b + d) \varepsilon
    \]
    <p>Identity of Addition:</p>
    \[
        (a + b \varepsilon) + (0 + 0 \varepsilon) = a + b \varepsilon
    \]

    <p>For the C++ implementation of dual number addition, see
        <a href="https://github.com/XiaoxingChen/mxm/blob/e004ef892dce35436194b5b7a93c7e522c256fbe/inc/mxm/linalg_dual_number.h#L93">
        mxm/linalg_dual_number.h:93</a>.</p>

    <h2 id="multiplication">Multiplication</h2>
    \[
        (a + b \varepsilon)(c + d \varepsilon) = ac + (ad + bc) \varepsilon
    \]

    <h3>Conjugate</h3>
    <p>Denote \(x = a + b \varepsilon\), its conjugate \(\bar x\) is denote as: </p>
    \[
        \bar{x} = a - b \varepsilon
    \]
    <p>Then, \(\bar{x} x = a^2 - b^2 \varepsilon^2  = a^2\). </p>

    <p>Identity of Multiplication:</p>
    \[
        (a + b \varepsilon)(1 + 0 \varepsilon) = a + b \varepsilon
    \]

    <p>Inversion of Multiplication:</p>
    \[
    \begin{align}
        \frac{1}{a + b \varepsilon} &= \frac{a - b \varepsilon}{(a + b \varepsilon) (a - b \varepsilon)}\\
        &= \frac{a - b \varepsilon}{a^2} \\
    \end{align}

    \]
    <p>Where \(a \neq 0\). Dual number division uses conjugate property to eliminate the denominator.</p>

    <p>For the C++ implementation of dual number multiplication, see
        <a href="https://github.com/XiaoxingChen/mxm/blob/e004ef892dce35436194b5b7a93c7e522c256fbe/inc/mxm/linalg_dual_number.h#L22">
        mxm/linalg_dual_number.h:22</a>.</p>

    <h2>Derivative</h2>
    <p>
        For all functions that can be expanded as Taylor Series at point \(x_0\) :
    </p>
    \[
        \begin{align}
            f(x) &= f(x_0)
            + \frac{f^ {\prime} (x_0)}{1!}(x-x_0)
            + \frac{f^ {\prime \prime} (x_0)}{2!} (x-x_0)^2
            + \frac{f^ {\prime \prime \prime} (x_0)}{3!} (x-x_0)^3
            + \cdots \\
            &= \sum_{\infty }^{n=0} \frac{f^{(n)}(x_0)}{n!} (x-x_0)^n \\
        \end{align}
    \]
    <p>Set \(x = a + b \varepsilon\) and expand the series at \(x_0 = a\),  </p>
    \[
        \begin{align}
            f(a + b \varepsilon) &= f(a)
            + \frac{f^ {\prime} (a)}{1!} (b\varepsilon)
            + \frac{f^ {\prime \prime} (a)}{2!} (b\varepsilon) ^2
            + \frac{f^ {\prime \prime \prime} (a)}{3!} (b\varepsilon) ^3
            + \cdots \\
            &= f(a) + f^ {\prime} (a) (b\varepsilon)  \tag{2-5}\\

        \end{align}
    \]

    <p>i.e.</p>
    \[
        f^{\prime }(a) \varepsilon =  \frac{ f(a + b \varepsilon) - f(a) }{b} \tag{2-6}
    \]

    <h1>Dual Number Elementary Functions</h1>
    <p>
        In order to use dual number in C++ project, simply overloading operators like <code>+ - * /</code>
        is not enough. C++ built in functions such as <code>sin</code>, <code>cos</code>, <code>exp</code>, <code>log</code>
        don't handle dual number input. The dual number class have to support all these functions.
    </p>
    <p>
        Luckily, most elementary functions of dual numbers can be converted to the combination of C++ built in functions.
        For example:
    </p>
    <p>By applying formula: \(\sin(u + v) = \sin(u) \cos(v) + \cos(u) \sin(v)\) and \(\lim_{x \to 0} \frac{\sin(x)}{x} = 1 \)  </p>
    \[
    \begin{align}
        \sin(a + b \varepsilon) &= \sin(a) \cos(b \varepsilon) + \cos(a) \sin(b \varepsilon) \\
        &= \sin(a) \cdot 1 + \cos(a) b \varepsilon \\
        &= \sin(a) + b \cos(a) \varepsilon
    \end{align}
    \]
    <p>Or by applying formula (2-5): \(f(a + b \varepsilon) = f(a) + f'(a) (b \varepsilon)\) </p>
    \[
        \sin(a + b \varepsilon) = \sin(a) + b \cos(a) \varepsilon \tag{3-1}
    \]

    <p>Thus the C++ implementation of the <code>sin</code> function for dual number is:</p>
    <pre>
    template &lt;typename DType> DualNumber &lt;DType>
    sin(const DualNumber &lt; DType>& val)
    {
        return {std::sin(val(0)), std::cos(val(0)) * val(1)};
    }
    </pre>

    <h2>Mostly Used Elementary Functions</h2>
    \[
    \begin{align}
        \sin(a + b \varepsilon) &= \sin(a) + b \cos(a) \varepsilon \\
        \arcsin(a + b \varepsilon) &= \arcsin(a) + \frac{b \varepsilon}{\sqrt{1-a^2}} \\
        \cos(a + b \varepsilon) &= \cos(a) - b \sin(a) \varepsilon \\
        \arccos(a + b \varepsilon) &= \arccos(a) - \frac{b \varepsilon}{\sqrt{1-a^2}} \\
        \exp(a + b \varepsilon) &= \exp(a) + b \exp(a) \varepsilon \\
        \ln(a + b \varepsilon) &= \ln(a) + \frac{a}{b} \varepsilon \\
        (a + b \varepsilon)^ \alpha &= a^ \alpha + (\alpha b)  a^{\alpha - 1} \varepsilon \\
    \end{align}

    \]
    <p>For the C++ implementation of the elementary functions above, see
        <a href="https://github.com/XiaoxingChen/mxm/blob/e004ef892dce35436194b5b7a93c7e522c256fbe/inc/mxm/linalg_dual_number.h#L138">
        mxm/linalg_dual_number.h:138</a>.</p>

    <h1>Derivative of 3D Special Orthogonal Group</h1>
    <p>
        Consider a rotation axis \(\phi \in \mathbb{R}^{3} \) and \(\| \phi \| = 1 \),
        a rotation along axis \(\phi\) with angle \(\theta\) can be expressed as \(f(\theta) = \exp (\theta \phi^ \wedge) \).
        The \((\cdot )^ \wedge \) operation converts a 3D vector into a skew-symmetric matrix.
    </p>
    <p>Meanwhile, \(f'(\theta) = \phi^ \wedge \exp(\theta \phi^ \wedge)\) and \(f^{(n)}(\theta) = (\phi^ \wedge)^n \exp(\theta \phi^ \wedge)\) </p>
    <p>The Taylor Series of \(f(\theta)\) at point \(\theta_0\) is:</p>
    \[
    \begin{align}
        f(\theta) &= f(\theta_0) + \frac{f'(\theta_0)}{1!}(\theta - \theta_0) + \frac{f''(\theta_0)}{2!}(\theta - \theta_0)^2 + \cdots   \\
        &= ( I + \phi^ \wedge (\theta - \theta_0) + \frac{(\phi^ \wedge)^2}{2!}(\theta - \theta_0)^2 + \cdots  ) f(\theta_0)\\
        &= \left( \sum_{n=0}^{\infty } \frac{(\phi^ \wedge)^n}{n!} (\theta - \theta_0)^n \right) f(\theta_0)
    \end{align}

    \]

    <p>Let \(\theta = a + b \varepsilon\) and \(\theta_0 = a\), then  </p>
    \[
        f(a + b \varepsilon) = (I + \phi^ \wedge b \varepsilon) f(a)
    \]
    \[
        \frac{f(a + b \varepsilon) - f(a)}{b} = \phi^ \wedge f(a) \varepsilon
    \]

    <p>The DoF of a 3D rotation is 3, therefore three orthogonal rotation vectors are required to
        find all derivative of a rotation function. Normally the standard orthogonal basis
         \([0,0,1]^\top, [0,1,0]^\top, [1,0,0]^\top\) are used as \(\phi\) .
    </p>

    <h2>Rodrigues Formula</h2>
    <p>Rodrigues formula is essential the exponential map from \(\mathfrak{so}(3)\) to \(SO(3)\).  </p>
    <p>Denote \(\varphi = \theta \phi\) </p>
    <!-- \[
        \exp(\theta \phi) = I + \sin(\theta) \phi^ \wedge + \cos (\theta) \phi^ \wedge \phi^ \wedge
    \] -->
    \[
        \exp(\varphi) = I + \frac{\sin(\theta)}{\theta}  \varphi^ \wedge + \frac{\cos (\theta)}{\theta^2}  \varphi^ \wedge \varphi^ \wedge
    \]

    <p>
        The numerical accuracy decrease when \(\theta \rightarrow 0\).
        In normal C++ implementation,
        an <code>if</code> expression
        is used to eliminate the singularity:
    </p>
        \[
            \| \varphi \| &lt; \epsilon \Rightarrow  \exp(\varphi) = I
            \tag{4-3}
        \]
    <p>
        Where \(\epsilon\) is the machine accuracy.
        However the expression is incorrect when dealing with dual number input.
    </p>
    <p>Denote </p>
    \[
        \varphi =
        \left[
        \begin{matrix}
            a_1 + b_1 \varepsilon \\
            a_2 + b_2 \varepsilon \\
            a_3 + b_3 \varepsilon \\
        \end{matrix}
         \right]
    \]
    <p>
        Denote \(a = [a_1, a_2, a_3]^\top\). \(\theta = 0 \Rightarrow  \|a\| = 0
        \Leftrightarrow
        \varphi ^ \wedge \varphi ^ \wedge = 0 \) but \( \not \Rightarrow  \varphi ^ \wedge = 0\).
        Therefore, the expression (4-3) should be corrected to
    </p>

    \[
            \| \varphi \| &lt; \epsilon \Rightarrow  \exp(\varphi) = I + \varphi^ \wedge
            \tag{4-4}
    \]

    <p>
        <a href="https://github.com/XiaoxingChen/mxm/blob/e004ef892dce35436194b5b7a93c7e522c256fbe/inc/mxm/lie_special_orthogonal.h#L173">Here</a>
        is the C++ implementation of the Rodrigues formula that supports dual number calculation.</p>

    <h2>A Demo with Rotation Auto Derivative</h2>
    <p>Perspective N Point(PnP) problem tends to find the camera pose by minimizing the reprojection error
        between 2D points. It is a typical nonlinear optimization problem with the state vector
        constrained on a 6 DoF manifold. The demo use dual number auto derivative to find the Jacobian matrix
        and the method converged correctly.
    </p>
    <p>
        See <a href="https://github.com/XiaoxingChen/mxm/blob/e004ef892dce35436194b5b7a93c7e522c256fbe/inc/mxm/cv_3d.h#L317">mxm/cv_3d.h:317</a> for Jacobian matrix
        calculation and
        <a href="https://github.com/XiaoxingChen/mxm/blob/e004ef892dce35436194b5b7a93c7e522c256fbe/tests/test_cv_basic.cpp#L537">tests/test_cv_basic.cpp:537</a>
        for PnP problem verification pipeline.
    </p>
    <h1>Limitations</h1>
    <p>
        Consider real number expression \(c = \frac{ab}{b}\). It is easy to find \(c = a\) when \(b \neq 0\)
        but hard to define the value of \(c\) when \(b = 0\).
        Similarly for dual number: \(x \neq \sqrt[]{x^2}\) when \(x\) is a purely nonreal dual number, i.e. \(x = b \varepsilon\).
    </p>


    <h1 id="references">References</h1>
    <ol class="bib">
        <li>
            Michael Penn,
            <cite>
                <a href="https://youtu.be/ceaNqdHdqtg">"The strange cousin of the complex numbers - the dual numbers."</a>
            </cite>
            YouTube, 2022
        </li>
        <li>
            Wikipedia,
            <cite>
                <a href="https://en.wikipedia.org/wiki/Dual_number">
                    "Dual number."</a>
            </cite>

        </li>


    </ol>
</body>